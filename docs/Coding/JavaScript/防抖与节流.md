
#js #防抖 #节流
# 防抖与节流区别

防抖（Debounce）和节流（Throttle）是两种常用于优化前端事件处理的技术，它们都可以用于减少频繁触发的事件的执行次数，提升性能。然而，它们的原理和应用场景有所不同。

1. **防抖（Debounce）：**
   防抖的核心思想是，当一个事件被触发后，如果在一定的时间内没有再次触发该事件，才会执行事件处理函数。如果在这段时间内又触发了该事件，那么重新计时，等待一定的时间再执行。防抖通常用于防止在短时间内连续触发的事件，如窗口大小变化、输入框输入等，以减少频繁的操作。

   示例：在搜索框输入时，等用户停止输入一段时间后再执行搜索操作，以减轻服务器负担。

2. **节流（Throttle）：**
   节流的核心思想是，无论事件触发频率多高，都会按照固定的时间间隔执行事件处理函数。节流可以稳定地限制事件的执行频率，确保事件处理函数在一段时间内只执行一次。节流适用于需要固定频率执行的事件，如页面滚动、鼠标移动等。

   示例：在滚动页面时，每隔一段时间执行滚动事件处理函数，避免事件处理函数过于频繁地执行。

总结：
- 防抖适用于需要等待一段时间后执行的事件，它确保在一段时间内**只执行一次事件**处理函数。
- 节流适用于需要**固定频率执行的事件**，它稳定地将事件处理函数执行间隔在一定时间内。

你可以根据具体的需求选择使用防抖还是节流来优化你的事件处理逻辑。

![[00 Attachment/Pasted image 20230814224703.png]]

# 防抖

## 防抖的应用例子

![[00 Attachment/Pasted image 20230814224946.png]]

## 防抖函数实现(闭包)

```js
function debounce(fn, delay=500) {
    let timer = null;

    return function() {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}
```
# 节流

## 节流的应用例子

## 节流函数的实现（闭包）

```js
function throttle(func, wait = 50) {
  let timer = null;

  return (...args) => {
    if (timer) return;

    timer = setTimeout(() => {
      func.apply(this, args);
      timer = null;
    }, wait);
  };
}
```
